# Chapter 5: NgModules

So far we've discussed the architecture of an Angular project, we've created the basic version of our demo application, the Client Contacts Manager, and we've added some components to this application. Everything we've done so far has all been developed within the single module that Angular generates for us.

In this chapter, we will start looking further into Modules in Angular; we have already seen new modules being used when we added Angular Material and Forms to our example application, but now we are going to look into how modules are structured, what each part of the module file does, and how to create them using the Angular CLI.

We will then look at why modules are used and how they help divide up the functionality of the application, especially for large enterprise applications. Then, we will continue expanding on our example application by adding new modules for the various sections of our application. The aim of this chapter is to help you to start thinking about how, when you come to develop your own Angular application, you can see how you can use Modules to structure your application.

At the end of this chapter you will learn the following:

- How modules are structured
- How to add your components to a module
- How to create modules using the CLI
- How to separate functionality of an application using modules 
- How to plan the structure of their applications using modules

## What are modules in Angular?
Modules have always been a part of Angular; from the AngularJS days, modules have been a core part of an Angular application. In Angular 2+, a new way of creating modules was introduced. The new `@NgModules` class was introduced as the new way to create modules of functionality in an application.

This new approach allows us as Angular developers to group together the elements of the module (the components, services, pipes, and directives) under a module, then we can group individual modules together to make a complete application. In the same way, we would put pieces of a puzzle together to make a complete picture.

The NgModule class allows us to create a public API of the components available in the module. In the NgModule class, we export the elements (the Components or Services) of the module so these elements can be accessed by other modules in our application.

Let us take a look at an example of a `@NgModule` class so we can explore how a module is structured:

```
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { AppComponent } from './app.component';

@NgModule({
     imports: [BrowserModule],
     declarations: [AppComponent],
     bootstrap: [AppComponent]
})
export class AppModule { }
```

In this `app.module.ts` file, we've created a module that imports the Angular `BrowserModule`, declares the `AppComponent`, and sets the same AppComponent as the first component to run when the application starts.

> The BrowserModule is part of the Angular framework. It provides all the functionality needed by the framework to start an application running in the browser. For more information on this module check out the official Angular docs: [https:/​/angular.​io/​api/​platform-​browser/](https:/​/angular.​io/​api/​platform-​browser/BrowserModule)

Then in the `main.ts` file, which is a TypeScript file the Angular CLI creates as part of an application, tells Angular what module to call when booting up/starting the application:

```
 import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 import { AppModule } from './app/app.module';
 
 platformBrowserDynamic().bootstrapModule(AppModule);
```

In the preceding example, we can see that the `platformBrowserDynamic` class of the Angular platform has been imported, and then almost immediately, the `bootstrapModule()` function of this class is called with the `AppModule` class of our application passed in as the module that Angular will use to start our application.

This is how an Angular application starts. It needs one NgModule class to start the application, then from there, all the other modules of our application are imported into AppModule for the framework to find and be able to load when needed as the application runs in the browser.

If you look at our project, you'll see that there are other modules within Angular. These modules are how functionality is grouped together so this functionality can be imported or added to our own modules.

You'll see that in the import statements, these are the lines of code at the top of our file; these show how different modules are added. For example, at the top of a Module file, you'll see the following:

`import { NgModule } from '@angular/core';`

This is an import statement where we are adding the `NgModule `class from the angular/core module. This angular/core module is part of the Angular framework that contains a set of TypeScript classes, which provide the core functionality of the Angular framework. Creating a Module is part of this core functionality, so this is part of the Angular/core module.

As you learn more about Angular, you'll see other modules, such as the root module. This module handles all the bootstrapping of the application. Its role is to manage the startup of the application. If you look at the `main.ts` file of an Angular application, you'll see the following code:

`platformBrowserDynamic().bootstrapModule(AppModule).catch(err => console.error(err));`

This is where the framework is taking the `AppModule` and setting it as the module that will be run first as part of this startup process.

Angular makes use of modules, not only to group pieces of functionality together but also as a way to access and make use of the core functionality of the framework.

So the importance of understanding how modules work and can be used within an Angular application is extremely important. Now, let's look more in-depth at the various parts of a `NgModule` file.

## The parts of the NgModule file
When the Angular CLI creates a new application, it generates a single NgModule file for us. This file is always called `app.module.ts` and looks like this:

```
    import { BrowserModule } from '@angular/platform-browser';
    import { NgModule } from '@angular/core';
    import { AppRoutingModule } from './app-routing.module';
    import { AppComponent } from './app.component';
    
    @NgModule({
       declarations: [AppComponent],
       imports: [
           BrowserModule,
           AppRoutingModule,
           BrowserAnimationsModule,
       ],
       providers: [],
       bootstrap: [AppComponent]
    })
    
    export class AppModule {}
```

There isn't a lot actually going on here; there aren't any functions, events, or loops in the main AppModule class. Everything is within the `@NgModule` decorator. There are three categories of metadata that the `@NgModule` decorator uses. These categories are as follows:

- Static 
- Runtime 
- Composition

The **Static** category of the `@NgModule` decorator is all about telling the compiler about the selectors, and where these selectors should be applied in the templates we create. This is how Angular knows what template files to use. When Angular finds one of our selector tags in a template; the framework knows to go and get the template from a component and replace that selector tag.

> The selector tag is set in a components `@Component` decorator, it gives a component it's element tag, for example `<app-my-component>`.

The **Runtime** category of metadata within the `@NgModule` decorator is how the injection of providers/services is set. So the module knows what services will need to be injected into components throughout the module. The module keeps this "list" of possible providers/services that it could possibly need so when a component adds the service through its constructor, the Angular compiler knows where to inject this service from.

The final category of metadata is **Composition**. This is how different `@NgModules` know about each other and are available to each other. This is how Angular structures modules together—through this metadata of other modules—building up this tree of modules that make up our application.

So let's now take a look at each of the sections of the `@NgModule` in more detail.

### The Declarations Array
The Declarations section is one of the static metadata sections. In this, an Array is defined where all the component, directives, and pipes of this module are declared.

The components, directives, and pipes that are listed in this array can only belong to the **one** module.

If you add a component to more than one NgModule, the compiler will throw an error. A possible way to share a component in several different modules of your application is to declare the component in a "shared" module, then add this shared module into the other modules in your application. This pattern is the same approach libraries like Angular Material use; we import the Material module into our own modules to get access to its UI components.

By declaring the components, directives, and pipes in the Declarations array, we're telling Angular where it can find the tag selectors used throughout the application. Without this, Angular won't know what templates to use when it encounters a selector in our templates, so it is a crucial part of the compilation process.

### The Imports Array
Next is our example module is the Imports array, which contains the composition category of metadata. This array contains the names of the other modules that can be included in this module and it is the components, directives, or pipes that are exported by these modules that make them available in other modules.

Basically, the way components are shared between modules is by setting at the module level which of its component, directives and pipes are set as exported; then when the module is imported into another module, these exported elements can be used in the module that has imported in the other module.

Examples of this use of the **Imports** array include the `FormsModules`, which we have already seen in *Chapter 5, Components, Templates, and Forms*. In that chapter, when we started adding both the Template Driven form and the Reactive forms to our Client Contacts Manager application, we imported the `FormsModule` into our `AppModule`. By doing this, we had access to all the components and directives that the `FormsModule` has set as accessible in its **Exports** Array.

### The Exports Array
The Exports Array is the other composition metadata array, both this and the Imports Array are closely related.

The Exports array contains this list of components, directives, and pipes that can be used by the importing module. Until this point, all the components and so on are private within the module; when they are listed in the Exports array they are declared public.

If we think of this as a TypeScript class, all we are doing is setting what properties are public, by setting them in the Exports Array, so when we make an instance of this TypeScript class, the public properties are available in the class that is using this new instance of our TypeScript class.

This is what we're doing with the exports array; we're telling the Angular compiler that the components, directives, and pipes declared in this array are public and accessible in other modules, but only if the other module includes the `NgModule` this export array is defined in.

This means that not all of your components need to be added to the Exports array, only the ones you want to be made available to other modules of the application.

### The Providers Array
The Providers Array is part of the runtime metadata of our NgModule decorator. In this array, we list all the providers that can be injected via Dependency Injection into our components.

> **Dependency Injection** is a way of passing objects/services to other objects instead of using a factory class to generate these new objects. With dependency injection, objects are passed into other objects when needed. We will be exploring dependency injection in *Chapter 7, Dependency Injection, Service, and HttpClient*.

By adding these providers to this Providers Array, we're registering them with the module and it makes them available to all of the component, directives, and pipes within this module. Without doing this, we could find that when we try to use one of these services later in a component, the compiler will throw an error, telling us that the service we want is not registered with the parent module.

The Angular compiler is extremely smart; it will let us know if we are trying to use a provider that isn't registered, but it is better to remember to add our services to the Providers Array beforehand.

### The Bootstrap Array
This array is another static type of metadata. It contains a list of the components that will be automatically bootstrapped/started when the compiler runs this module.

Usually, this Bootstrap Array has one component; as we can see from our `app.module.ts` file, in the bootstrap array of this module we have just the `AppComponent` listed. This means that the `AppComponent` will be called when the module starts running.

I did say that there is usually only one component listed in the bootstrap array, but is it possible to add more than one, but why would you do this? Well, if you had an application that, when it loads has to display two components in two different parts of the first page (if for example, the application has two views on the first page, one showing a component display a list of usernames and the other view showing a list of email addresses), this means you may need to start two components at the same time when you would add both components to the bootstrap array.

Any components that are listed in this bootstrap array are automatically added to the `entryComponents` array, which we are going to be looking at next.

### The entryComponents Array
This array is another static metadata array, and it contains a list of the components that can be dynamically loaded into the view.

When an Angular application starts, it uses the component listed in the bootstrap array to start the application and load the bootstrap listed component into the view. Then, as the user navigates throughout the application, they move through a list of routes, which we define, and as part of this route definition, we set what component is loaded when that route is run.

> We will be going through routes and defining routes in Chapter 6, Routing and Navigation, where we will see how to define these components that run as part of a route.

So, we now know of two ways that a component is automatically loaded into the view; either when it's set in the bootstrap array or when it's defined in a route. For Angular to know of these components at the time the module is being compiled, Angular automatically adds these components to the `entryComponents` array.

So this covers the main parts of the `@NgModule` decorator; now we are going to use the Angular CLI to create some more modules for our Client Contacts Manager application.

## How to create modules using the CLI
So we've covered the metadata of the `@NgModule` decorator and now it's time to start creating our own modules. Now we know the structure of a `NgModule` class, we could start writing our modules by hand, but thankfully, the Angular CLI team have created a way we can generate modules with a few simple commands.

To create a new module using the CLI, we simply use the generate command we've already used to generate new components in our example application. The full command for creating a module is as follows:

`ng generate module <modulename>`

So if we wanted to create a new module called **AdminModule**, we would simply use this command:

`ng generate module AdminModule`

Or use the shortcut format as follows:

`ng g module AdminModule`

While these commands will generate a new NgModule file for us, sometimes we may want to tell the CLI where to create this new module. For example, if we are creating this `AdminModule`, we may want it to be generated in a folder called admin. There are two ways we can do this; first, we can navigate to the admin folder within a Terminal, then run the `ng generate module` command, or we can put the complete path before the name of the new module to be generated like so:

`ng generate module admin/AdminModule`

This will then generate for us the new module TypeScript file in the following:

`src/app/admin/admin-module/admin-module.ts`

As you can see, what the CLI has done is created a folder called `admin-module` within the `admin` folder. The CLI uses the name we've provided for our module to create a unique folder name.

Now that we've created a new module, we can start adding Components to this newly created module, but before we do, let's recap on our folder structure.

If we create this new admin module in the `angular-architecture` project we created earlier, in Chapter 2, Angular Architecture. Our new folder structure will look like this:

![Admin Module](images/chapter5/AdminModule.png "Admin Module")

See now we have this new `admin/admin-module` and inside that folder, we have `admin-module.module.ts`, which is a very basic NgModule file, but it is enough for us to start using the following:

```
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';

@NgModule({
    imports: [
        CommonModule
    ],
    declarations: []
})

export class AdminModuleModule { }
```

Then in order for this new `sub-module` to be added to our main `AppModule`, we simply add it to **imports** array like this:

```
@NgModule({
    declarations: [
        AppComponent
    ],
    imports: [
        BrowserModule,
        AdminModuleModule
    ],
    bootstrap: [AppComponent]
})

export class AppModule { }
```

Then as we create new components within our new admin section, these components are added to the new `AdminModule`, which through being imported into the main AppModule, makes these "admin" components part of our final application.

A good way to think of this is seeing modules as trees of components, and each module is linked to the next, building up each individual tree module, and this is how we can see the application. Angular can then *watch* this set of trees and it knows what each component is, where it is, and how to use the component when needed.

Being able to create modules so easily can lead us to start creating modules for everything. This is the beauty of the Angular CLI; it allows us to take repetitive tasks and makes the simple one-line commands we can run in order to generate new code for our application. However, doing this means we need to start thinking about the structure of our applications and how we are going to start using modules.

## Creating modules for our Client Contact Manager application
Now we know how to use the Angular CLI to create modules, we can start to look at moving our Client Contact Manager application that we're building throughout this book forward. Let's now review the application we're building and see how we can use our knowledge of modules to start building out the functionality of the application.

The application we're building consists of two main sections: Clients and Companys. In the Client section the user will be able to do the following:

- View list of their clients 
- Add a new client 
- Search for a client
- Edit a client's details 
- Delete a client

While in the Company section, they will be able to do the following:

- View the list of Companys 
- Add a new Company
- Search for a Company
- Edit the details of a Company 
- Delete a Company

Both use cases are very similar, but we can clearly see that there is a need for two separate sections on the application. The user may decide that they just want to add a new company in order to add a new client to the system for this company. So, their first step may be just to enter the Company details or they just might decide to use the system to look up the contact details of their favourite client.

So, taking what we know are the two main use cases for the application, we could think that we only really need to use two modules in order to structure our application: one `@NgModule` for the Client section and one `@NgModule` for the Company section, but there are actually more modules we use in this application.

### Modules of our application
As we know modules in Angular can be seen as a series of trees, and each tree has a set of components that branch off out of the module. So for this application, we'd have a `NgModule` for the Client section, and we would also have a `NgModule` for the Company section, but we also need to have the main `AppModule`, which connects both the Client and Company modules together. Here is an actual list of the modules we will be creating:

- AppModule
- ClientModule
- CompanyModule
- SharedModule
- CustomMaterialModule

There's five in total, let's go through each one and see what it will be doing within the application.

- **AppModule**: The main module of our application and the default one the Angular CLI creates when it generates a new Angular application. It will have all the UI components needed to create the shell of the application.
- **ClientModule**: The main module of the Client section. This is a child module of the `AppModule` but contains all the components for the Client section UI.
- **CompanyModule**: The main module of the Company section. Again a child of the AppModule, but contains all the components for the Company UI.
- **SharedModule**: This module is used to share components across both the Client and Contacts.
- **CustomMaterialModule**: This module is used to import modules we may need from the Angular Material UI library.

The final one, `CustomMaterialModule`, has a unique use case. The reason we're creating this module is that the Angular Material UI library has a large set of UI components, and in order to make the UI library as small as possible, the team who run the Angular Material project have set up the library so that, in order to use a certain UI component, we need to import the `NgModule` of that component. For example, we are going to add a new toolbar to the top of our application. To do this, we need to import into our application the `MatToolbarModule` from Angular Material. Now, we could do this import within our `AppModule` imports array, but as our application grows and we use more and more UI components from Angular Material, this list of modules we're adding to the import array will get too big and it will become unmanageable.

So a way around this issue is to create a wrapper module where we can import in all the modules from Angular Material we want, then we simply import this wrapper module into our main `AppModule`. This wrapper module, `CustomMaterialModule`'s sole job is to import the modules we need from Angular Material, so the code within the module is very clean; it's just the imports array. Then adding this to the AppModule helps keep the AppModule code very clean and readable.

This idea of having a wrapper for the Angular Material components is something that the official documentation of Angular Material suggest themselves, [https:/​/​material.angular.​io/​guide/​getting-​started#step-​3-​import-​the-​component-​modules](https:/​/​material.angular.​io/​guide/​getting-​started#step-​3-​import-​the-​component-​modules).

This is why we will create the CustomMaterialModule in order to add all these Angular Material modules in the one wrapper module.

Now, let us start creating the `ClientModule` and `CompanyModule` of our application. We already have a clients folder we created when generating the client-page and client-form components during *Chapter 4, Components, Templates and Forms*. If we go to that folder in VSCode and create a new TypeScript file called `client-module.ts`, in this file, we need to add this code:

```
    import { NgModule } from '@angular/core';
    import { CommonModule } from '@angular/common';
    @NgModule({
       imports: [CommonModule]
    })
    export class ClientModule {}
```

Now we need to create the `CompanyModule`. First, under the app folder we need to create a new `company` folder under the app folder, then inside the company folder, create a new TypeScript file called `company.module.ts`, and inside that file, add the following code:

```
    import { NgModule } from '@angular/core';
    import { CommonModule } from '@angular/common';
    @NgModule({
       imports: [CommonModule]
    })
    export class CompanyModule {}
```

Great, now we have our two modules. We need to now add these modules to our `app.module.ts` in order to link these new modules with our app module. To do that, we add these modules to the `import` statement of `app.module.ts` as follows:

```
imports: [
    BrowserModule,
    AppRoutingModule, 
    BrowserAnimationsModule, 
    ClientModule, 
    CompanyModule, 
    FormsModule,
    ReactiveFormsModule
]
...
```

Now we've done a lot of adding new code to our application, let's run the app to make sure everything is still running ok. Again, if we run this command, the Angular CLI will run our application and open it in the browser as follows:

`ng serve -o`

If everything is running ok, we now can do a little tidying up of our components and the new modules we have just created.

## Adding our Client components to the ClientModule
Now we've created the `ClientModule`, we can add all our Client components to this module in order to start structuring our application into the different areas of functionality. When we do this refactoring, we will encounter a couple of issues, but first let's make the changes then we can go through the problems we encountered and why they happened.

This is our new `client.module.ts` file as follows:

```
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ClientPageComponent } from './client-page/client-page.component';
import { ClientFormComponent } from './client-form/client-form.component';
import { ReactiveFormsModule } from '@angular/forms';

@NgModule({
       declarations: [ClientPageComponent, ClientFormComponent],
       imports: [CommonModule, ReactiveFormsModule]
})
export class ClientModule {}
```

As you can see, we've made a couple of changes; first, we've added the `ClientPageComponent` and the `ClientFormComponent` to the declarations array of the module. As we know, the declarations array is how we tell the `ClientModule` what components belong to it. So, when the `ClientModule` is imported into another module, say the `AppModule`, the `AppModule` knows what component, directive, or pipes belong to `ClientModule`.

Next, we have to import the `ReactiveFormsModule`; this is because we are using a Reactive Form in our Client Form module. Remember modules are encapsulated so even we adding the `ReactiveFormsModule` to AppModule and then add the `ClientModule` to `AppModule`, it doesn't mean that the `ClientModule` knows that `ReactiveFormsModule` is included into AppModule. `ClientModule` needs to have a direct connection to `ReactiveFormsModules`, and this is what we are doing by adding it into the `ClientModule` imports array.

Now, if we run the app again using `ng serve -o`, we will find that the app is blank. If we look in the browser console, we will see that the Angular compiler is complaining that the `app-search-form` isn't found. Why is this? Well, the reason is when we originally created the `ClientPage` component in *Chapter 4, Components, Templates, and Forms*, we added the new `SearchForm` component to the `ClientPage` but declared the `SearchForm` component as part of the `AppModule`.

So when the `ClientPage` component became part of the `ClientModule` as we did not also make the `SearchForm` part of this `ClientModule`. When the `ClientPage` was loaded into our application, the Angular compiler was also looking for the `SearchForm` component within the `ClientModule`, because the `ClientPage` is now part of this module, but as we haven't moved the `SearchForm` into the `ClientModule` the Angular compiler can't find the `SearchForm` in this `ClientModule`, so it throws an error.

So how can we fix this? Well, there are a number of ways. We could add the `SearchForm` component to the `ClientModule` or we could move the `SearchForm` component out of the `ClientPage` component's template and add it to the AppComponent template. Both of these options are great, but let's think about what the role of the SearchForm component is for a second to decide what is the better solution.

The `SearchForm` component will allow the user to search through either the Client's list or the Company's list to find a matching record. So the `SearchForm` component will be used in either the **Client** section or the **Company** section and its functionality will be shared across both areas of the application. This sounds like the `SearchForm` component needs to be part of a `SharedModule`, which is one of the modules we listed as part of our list of modules for the application.

So let's create this new shared module, and add the `SearchForm` to it. First, we need to create a new folder for this shared module; this folder can also later house other components that will be shared across both sections. Under the app folder, create a new folder called shared and in this folder, create a new TypeScript file called `shared.module.ts`, and in that new TypeScript file, we add this code to make our new ShareModule as follows:

```
    import { NgModule } from '@angular/core';
    import { CommonModule } from '@angular/common';
    @NgModule({
       imports: [CommonModule]
    })
    export class SharedModule {}
   ```
   
Once we've created this module, we simply add it to the list of modules in the `AppModule` imports array like so:

```
imports: [
    BrowserModule,
    AppRoutingModule, 
    BrowserAnimationsModule, 
    ClientModule, 
    CompanyModule, 
    SharedModule, 
    FormsModule, 
    ReactiveFormsModule
] ...
```

Now in order to get the `SearchForm` as part of this new `SharedModule`, we need to add `SearchForm` component to the export array of the `SharedModule` as shown here:

```
@NgModule({
    declarations: [
        SearchFormComponent
    ], 
    imports: [
        CommonModule, 
        FormsModule
    ], 
    exports: [
        SearchFormComponent
    ]
}) ...
```

You may also notice we've added the `FormsModule`; the `SearchForm` component needs to have a reference to this module because we're using a form in the `SearchForm` component.

With this new `SharedModule`, we can add this to the `ClientModule` imports array in order to make the `SearchForm` available to the `ClientPage` component if we update our `ClientModule` to import the `SharedModule` as follows:

```
@NgModule({
    declarations: [
        ClientPageComponent, 
        ClientFormComponent
    ], 
    imports: [
        CommonModule, 
        ReactiveFormsModule, 
        SharedModule
    ]
   })
   export class ClientModule {}
```

Next, all we need to do is update the `client-page.template.html` to use the `SearchForm` component like so:

```
<h2>Add a new Client</h2>
<app-search-form></app-search-form>
<app-client-form></app-client-form>
```

If we rerun the app using `ng serve -o`, we should see the `SearchForm` component in the Client page as shown in the following screenshot:

![Client Contacts Manager App showing the Search Form ](images/chapter5/ContactManagerApp.png "Client Contacts Manager App showing the Search Form")

We've have made a lot of changes to our application, so before we move, on let us recap what we've done:

- Created a new module for the `Client` section and the `Company` section 
- Added these new modules to `AppModule`
- Moved all the `Client` components to the `ClientModule`
- Created a new `SharedModule`
- Added the `SearchForm` to the `SharedModule`
- Exported the `SearchForm` from the `SharedModule` so it can be found through the `SharedModule`
- Added the `SharedModule` to both the `AppModule` and `ClientModule `in order for them and their components to access the `SearchForm`

So we have basically taken our application and modularised it so as we move forward, adding more functionality to the application and the architecture of the app remains separated and easy to understand.

## Adding Angular Material
Now, while our application is modularised and well structured, it doesn't look that good, and we need to start changing that. We're going to use Angular Material to make the application look far more polished and presentable than it is now.

In order to add Angular Material, we need to start adding in the Modules from the Angular Material library that we added back in *Chapter 3, Getting Started with the Angular CLI* and by doing this, we will see how the use of Modules can quickly add a completely new design to our application.

### Creating a CustomMaterialModule
Earlier when we broke down the list of modules for this application, one of the modules we discussed was the `CustomMaterialModule`. This module allows us to add modules from the Angular Material library into one module of our application, then this custom module we will make accessible throughout our application.

The reason why we're doing this is because the Angular Material library exports its UI components through a set of modules. Now we could just import these modules into our AppModule, but as we mentioned earlier, this isn't a good idea because it will lead to the `AppModule` having a large imports array, and make it hard to read the `AppModule` code to know what is happening. So it is better practice to add all the UI modules we need from the Angular Material library into one custom module and then share that to our own modules. This is very similar to what we have just done with the `SharedModule`, where we added the `SearchForm` to this `SharedModule` and imported that module to the `ClientModule` in order to make the `SearchForm` component accessible to the `ClientPage` component. This time though, instead of sharing our own components, we are sharing the AngularMaterial components throughout our application.

The first thing we need to do is create this new **CustomMaterialModule**. To do this, we need to create a new TypeScript file in the app folder and call it `custom- material.module.ts`, then in that file, add the following code:

```
import { NgModule } from '@angular/core';
@NgModule({})
export class CustomMaterialModule {}
```

Next, as we did with the `SharedModule`, we need to import this new module into the imports array of `AppModule` as follows:

```
imports: [
    BrowserModule,
    AppRoutingModule,
    BrowserAnimationsModule, 
    CustomMaterialModule, 
    ClientModule, 
    CompanyModule, 
    SharedModule
] ...
```

Now we can start adding Material modules to this `CustomMaterialModule`, but first, let's have a look at Angular Material and the components we might want to add first.

If we go to the Angular Material website [https:/​/​material.​angular.​io](https:/​/​material.​angular.​io), we can see there are a number of components we can add to our application. These components are grouped by categories and they are as follows:

- **Form Controls**: Components for creating forms
- **Navigation**: Components for creating various ways of navigating through the application
- **Layout**: Components for the layout of our application
- **Buttons & Indicator**: Components for buttons, toggles, and status indicators
- **Popups & Modals**: Components to generate modals or popups in our applications
- **Data Table**: Components for showing and working with tabular data

From this list, we can see there are a large number of components we could use in our application, but as the application currently stands, we only need to add some layout components and form components. First, let's tackle the layout of our application.

### Amending the layout
This is what we are going to do—we're going to add a toolbar across the top of the app, put the Client form and Search forms in Card components to give them a container to sit in. We are going to update all the form controls to use Angular Material forms, giving them a cleaner look, and finally, we are going to add one of the predefined themes of Angular Material making the app look fresher.

This is what we will finally end up with:

![Client Contacts Manager App with MaterialUI ](images/chapter5/MaterialUI.png "Client Contacts Manager App with MaterialUI")

This looks far cleaner than the previous version. Let's go through the code changes we've made in order to achieve this look.

### Changes to CustomMaterialModule
In the `custom-material.module.ts`, we have added all the modules from Angular Material we needed to achieve this look. Now our `CustomMaterialModule` looks like this:

```
   import { NgModule } from '@angular/core';
   import { MatToolbarModule } from '@angular/material/toolbar';
   import { MatCardModule } from '@angular/material/card';
   import { MatFormFieldModule } from '@angular/material/form-field';
   import { MatInputModule } from '@angular/material/input';
   import { MatButtonModule } from '@angular/material/button';
   @NgModule({
       imports: [
           MatToolbarModule,
           MatCardModule,
           MatFormFieldModule,
           MatInputModule,
           MatButtonModule
    ], exports: [
           MatToolbarModule,
           MatCardModule,
           MatFormFieldModule,
           MatInputModule,
           MatButtonModule
    ] })
   export class CustomMaterialModule {}
```

Here, we've imported and exported all the modules from Angular Material that contain components we are going to use. Things like Material Toolbar and Material Card.

Then, we amended the `app.component.html` template to use the new Toolbar component as follows:

```
<mat-toolbar> {{ title }} </mat-toolbar>
<div class="container"><router-outlet></router-outlet></div>
```

This gives us the dark bar across the top with the title of the application. Next, let's look at the changes to `search-form.component.html` as shown here:

```
<mat-card class="search">
   <form class="search-form" (ngSubmit)="onSubmit()">
       <mat-form-field>
           <input matInput type="text" id="searchBox" placeholder="Search...." name="searchField" [(ngModel)]="searchField" />
       </mat-form-field>
        <button mat-raised-button color="primary" type="submit">Submit</button>
    </form>
</mat-card>
```

Here we've added the new `mat-card` component to the template and put the `search-form` within the `Card`. Then we added a new `mat-form-field` around the input form element. The matInput directive tells Angular Material that the input element is going to use the Material look. Finally, we added a `mat-raised-button` directive to make the Submit button have the Material raised button look.

Moving onto `client-form.template.html`, we are going to convert the Reactive Form we have in this template to use Material UI components like so:

```
<mat-card class="client-form">
       <mat-card-header>
           <mat-card-title>Add Client</mat-card-title>
       </mat-card-header>
       <form [formGroup]="clientForm" (ngSubmit)="saveClient()">
           <mat-form-field>
               <input matInput type="text" name="firstnameTxt"
   formControlName="firstname" placeholder="Firstname..." required />
           </mat-form-field>
           <mat-form-field>
               <input matInput type="text" name="lastnameTxt"
   formControlName="lastname" placeholder="Lastname..." required />
           </mat-form-field>
           <mat-form-field>
               <input matInput type="email" name="emailTxt"
   formControlName="email" placeholder="Email..." required />
           </mat-form-field>
           <mat-form-field>
               <input matInput type="tel" name="telephoneTxt"
   formControlName="telephoneNumber" placeholder="Telephone..." />
           </mat-form-field>
           <mat-form-field>
               <input matInput type="tel" name="companyTxt"
   formControlName="companyName" placeholder="Company Name..." required />
           </mat-form-field>
           <p>
               <button mat-raised-button color="primary" type="submit"
   [disabled]="!clientForm.valid">Save</button>
           </p>
       </form>
   </mat-card>
   
```

In this template, we've replaced all the input elements to use the `mat-form-field` components and added a `mat-raised-button` directive to the Submit button. We have also made some changes to the `client-form.component.scss` to improve the layout as follows:

```
.client-form {
       padding-top: 20px;
       margin-top: 40px;
       mat-form-field {
           width: 60%;
        }
        button {
           font: 1em sans-serif;
        } 
    }
```

We've added the width to the mat-form-field in order to make all the form fields the same width.

Finally, the last change we made was to add the Angular Material theme CSS file to the `style.scss` file as follows:

```
@import '@angular/material/prebuilt-themes/pink-bluegrey.css';

html,body {
       height: 100%;
}
body {
    margin: 0;
    font-family: Roboto, 'Helvetica Neue', sans-serif;
}
```

As you can see by just importing the module from Angular Material, we've been able to add just a couple of extra components into our application to drastically change the UI. This really shows how modules in Angular can add large amounts of new functionality (a completely new UI, for example) to an application just through a couple of lines of code.

We can make use of other third-party modules to plug in functionality to extend our applications. This ability to add new modules of functionality to our Angular applications is a real benefit. If we need to add a new feature to an application and there is a third-party module that helps with this feature, we can simply plug in this third-party module and start using the functionality this module provides.

## Summary
In this chapter, we've focused on the module system of Angular. We've been through how a NgModule class is structured, what the various parts of the module class are, and what goes into the various arrays of the module class. Then we went on to look at how the Angular CLI can create modules for us.

Next, we went on to add new modules to our Client Contacts Manager application so we can start to modularise the application. We look at how modules can be seen as trees of components grouping functionality under a parent module and we then explored how we can create modules that share functionality across parts of an application.

Finally, we used the power of modules to add new components from the Angular Material UI library in order to make the UI of our application look far better than it has previously.

The next thing we are going to look at as part of our learning Angular 8 is how to add navigation and routes to our application so the user can go from the Client section to the Company section and back.
